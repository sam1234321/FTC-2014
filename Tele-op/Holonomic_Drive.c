#pragma config(Hubs,  S1, HTMotor,  HTMotor,  none,     none)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Motor,  motorB,           ,             tmotorNXT, openLoop, encoder)
#pragma config(Motor,  motorC,           ,             tmotorNXT, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C1_1,     topLeft,       tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C1_2,     topRight,      tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C2_1,     bottomRight,   tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C2_2,     bottomLeft,    tmotorTetrix, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "JoystickDriver.c"

// NOTE: Some of to most of this code was made on npp, so the pragmas couldn't be setup and the selection of motors will likely change when a complete prototype of a bidirectional/holonomic drive robot has been built. - Nate

int speed; // Speed of the robot, used as a multiplier for speed. Should be positive
int threshold; // the "dead zone" of the controller joysticks

// All constant variables go here
const int FULLSPEED = 100; // a constant value for the maximum speed for the robot. Since this code doesn't have a precision mode, (yet), we only need fullspeed as a speed constant. Not neseccary at the moment, but will be later.
const int PRECISIONMODESPEED = 10; // for precise movement!
const int POWERSPEED = 20; // For moving kinda slow!

const int ARMSPEED = 20; // the default speed for which the arm will move

//Initialize Variables
void initializeVariables(){
	speed = FULLSPEED; // In the start of the program, the speed is the maximum.
	threshold = 10; // Just to keep unescessary movement.
}

// this is run before the main loop, to intitialize things for startup I. E. set servos to preffered starting positions
void initializeRobot(){
	initializeVariables();
}

// main method for movement.
void movement(int x1, int y1, int x2, int y2){
	if(joy1Btn(8) == 1){
		speed = PRECISIONMODESPEED;
	} else if(joy1Btn(7)){
		speed = POWERSPEED;
	}else {
		speed = FULLSPEED;
	}
	// we are only using x2 and y2 for the actual movement, x1 and y1 are for rotation. Optional, but reccomended and usef	ul.
	if(abs(y2) > threshold || abs(x2) > threshold || abs(x1) > threshold){ // make sure joystick is not in dead zone. I know, it only checks y2, but it is long a tedious to check for more, I'll do it later. ------------------------------------TODO-----------------------------------------------------------
		motor[topLeft] = ((y2 * speed) / 127) + ((x1 * speed) / 127) + ((x2 * speed) / 127);
		motor[topRight] = ((y2 * speed) / 127) - ((x1 * speed) / 127) - ((x2 * speed) / 127);
		motor[bottomLeft] = ((y2 * speed) / 127) + ((x1 * speed) / 127) - ((x2 * speed) / 127);
		motor[bottomRight] = ((y2 * speed) / 127) - ((x1 * speed) / 127) + ((x2 * speed) / 127);
	} else {
		motor[topLeft] = 0;
		motor[topRight] = 0;
		motor[bottomLeft] = 0;
		motor[bottomRight] = 0;
	}
}

void armMovement(int x1, int y1, int x2, int y2){
	if(abs(y2) > threshold){
		motor[armMotor] = ((y2 * ARMSPEED) / 127);
	}
}


task main(){

	waitForStart();

	initializeRobot();

	while(true){
		getJoystickSettings(joystick); // this should be run before joystick detection, since, well, the whole tele-op depends on the joystick.
		int y1 = joystick.joy1_y1; int y2 = joystick.joy1_y2; int x1 = joystick.joy1_x1; int x2 = joystick.joy1_x2; // Makes joystick positions easier to use
		movement(x1, y1, x2, y2); // Pass the joystick coordinates to movement method

		// The while loop doesn't need to be THAT fast... and it makes processing faster
		wait1Msec(1);
	}

}
